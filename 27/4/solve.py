"""
Фрагмент звёздного неба спроецирован на плоскость с декартовой системой координат. Учёный решил провести кластеризацию
полученных точек, являющихся изображениями звёзд, то есть разбить их множество на N непересекающихся непустых подмножеств (кластеров),
 таких что точки каждого подмножества лежат внутри квадрата со стороной длины H, причём эти квадраты между собой не пересекаются.
Стороны квадратов не обязательно параллельны координатным осям. Гарантируется, что такое разбиение существует и
единственно для заданных размеров квадратов.
Будем называть центром кластера точку этого кластера, сумма расстояний от которой до всех остальных точек кластера минимальна.
Для каждого кластера гарантируется единственность его центра. Расстояние между двумя точками на плоскости
В файле A хранятся данные о звёздах двух кластеров, где H=8 для каждого кластера.
В каждой строке записана информация о расположении на карте одной звезды: сначала координата x, затем координата y.
Значения даны в условных единицах. Известно, что количество звёзд не превышает 1000.
В файле B хранятся данные о звёздах трёх кластеров, где H=6 для каждого кластера. Известно, что количество звёзд не превышает 10 000.
 Структура хранения информации о звездах в файле B аналогична файлу А.
Для каждого файла определите координаты центра каждого кластера, затем вычислите два числа:
  – абсциссу центра кластера с наименьшим числом точек, и
  – ординату центра кластера с наибольшим числом точек.
В ответе запишите четыре числа: в первой строке сначала целую часть произведения
 ×10000, затем целую часть произведения
 ×10000 для файла А, во второй строке – аналогичные данные для файла B.
Возможные данные одного из файлов иллюстрированы графиком.
Внимание! График приведён в иллюстративных целях для произвольных значений, не имеющих отношения к заданию.
Для выполнения задания используйте данные из прилагаемого файла.
"""
from math import dist

fileA = open('27_A_21932.txt').readlines()
fileB = open('27_B_21932.txt').readlines()
clustersA = [[], []]  # два кластера в файле А
clustersB = [[], [], []]  # три кластера в файле B

for i in fileA:
    formatted_line = i.replace(',', '.')  # Для перевода в float разделение должно быть через точку
    x, y = [float(k) for k in formatted_line.split()]
    # Далее идет разделение по кластерам (в файле png с диаграммой из каждого файла)
    if y > 10:
        clustersA[0].append([x, y])
    else:
        clustersA[1].append([x, y])

for i in fileB:
    formatted_line = i.replace(',', '.')  # Для перевода в float разделение должно быть через точку
    x, y = [float(k) for k in formatted_line.split()]
    # Далее идет разделение по кластерам (в файле png с диаграммой из каждого файла)
    if y < 10:
        clustersB[0].append([x, y])
    elif x > 17:  # выполняется "Если y не меньше 10" при else if
        clustersB[1].append([x, y])
    else:  # в самом противном случае
        clustersB[2].append([x, y])


def center(cluster):  # определение центра кластера
    x, y = min(cluster, key=lambda a: sum([dist(a, i) for i in cluster]))
    # Координаты с минимальным расстоянием до всех остальных точек (в dist принимается два массива с координатами)
    return x, y


# Далее - определение медианных координат в файлах
def median(clustersX):  # дефолтное условие, которое обычно в ФИПИ
    centers = [center(cluster) for cluster in clustersX]
    x = 10000 * sum(i[0] for i in centers) / len(
        centers)  # В задании требуется умноженное на 10000 абсолютное целое значение
    y = 10000 * sum(i[1] for i in centers) / len(
        centers)  # В задании требуется умноженное на 10000 абсолютное целое значение
    return x, y


# Нахождение абсциссы центра кластера с минимальным количеством точек
def abscissofcoord(clustersX):  # странное условие из задания
    cluster = min(clustersX, key=len)
    x, y = center(cluster)
    return int(10000 * x)


# Нахождение ординаты центра кластера с максимальным количеством точек
def ordofcoord(clustersX):
    cluster = max(clustersX, key=len)
    x, y = center(cluster)
    return int(10000 * y)


print(abscissofcoord(clustersA), ordofcoord(clustersA))
print(abscissofcoord(clustersB), ordofcoord(clustersB))
